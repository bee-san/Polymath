<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How linked lists work with an application to Blockchain | Polymath.cloud</title>

<meta name="keywords" content="University, Computer Science" />
<meta name="description" content="The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.
Linked Lists are a linear collection of data elements. Linearty in a linked list is not defined by each element’s physical placement. Instead each data node in a linked list points to one or two other nodes in the linked list.
With an array such as [1, 2, 3] you know that the element 1 is at position [0] and element 2 is at position [1].">
<meta name="author" content="Bee">
<link rel="canonical" href="https://polymath.cloud/you-dont-understand-blockchain-unless-you-understand-this-simple-data-structure/" />
<link href="https://polymath.cloud/assets/css/stylesheet.min.94a69f3d0b70cac76c6d6f7dfecc9f91f2319ec73d54be960b0d3624fa5a25e2.css" integrity="sha256-lKafPQtwysdsbW99/syfkfIxnsc9VL6WCw02JPpaJeI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://polymath.cloud/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://polymath.cloud/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://polymath.cloud/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://polymath.cloud/apple-touch-icon.png">
<link rel="mask-icon" href="https://polymath.cloud/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />




<style>
    td, th {
    border: thin solid #999 !important;
    padding: 12px 15px;
}

thead tr {
    background-color: #009879;
    color: #ffffff;
    text-align: left;
}

table {
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 0.9em;
    font-family: sans-serif;
    min-width: 400px;
    overflow: auto;
    display: table;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
}

tbody tr {
    border-bottom: thin solid #dddddd;
}


tbody tr:last-of-type {
    border-bottom: 2px solid #009879;
}

tbody td.active-item {
    font-weight: bold;
    color: #009879;
}

tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
    }


body.dark tbody tr:nth-of-type(even) {
    background-color: #383838;
}


img {
    display: block;
    margin: auto;
    text-align: center;
}

</style>
<meta property="og:title" content="How linked lists work with an application to Blockchain" />
<meta property="og:description" content="The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.
Linked Lists are a linear collection of data elements. Linearty in a linked list is not defined by each element’s physical placement. Instead each data node in a linked list points to one or two other nodes in the linked list.
With an array such as [1, 2, 3] you know that the element 1 is at position [0] and element 2 is at position [1]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://polymath.cloud/you-dont-understand-blockchain-unless-you-understand-this-simple-data-structure/" />
<meta property="article:published_time" content="2019-10-10T16:19:24+00:00" />
<meta property="article:modified_time" content="2019-10-10T16:19:24+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How linked lists work with an application to Blockchain"/>
<meta name="twitter:description" content="The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.
Linked Lists are a linear collection of data elements. Linearty in a linked list is not defined by each element’s physical placement. Instead each data node in a linked list points to one or two other nodes in the linked list.
With an array such as [1, 2, 3] you know that the element 1 is at position [0] and element 2 is at position [1]."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How linked lists work with an application to Blockchain",
  "name": "How linked lists work with an application to Blockchain",
  "description": "The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.\nLinked Lists …",
  "keywords": [
    "University", "Computer Science"
  ],
  "articleBody": "The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.\nLinked Lists are a linear collection of data elements. Linearty in a linked list is not defined by each element’s physical placement. Instead each data node in a linked list points to one or two other nodes in the linked list.\nWith an array such as [1, 2, 3] you know that the element 1 is at position [0] and element 2 is at position [1].\nThe physical placement of each element defines the linearty of the array. This does not happen with linked lists.\nNodes make up elements in linked lists. Every node has a data section to it. As well as data, each node has a “forwards” and “backwards” section pointing to the previous and next node in the list.\nIn an array if you want to insert an item at [0] you need to shift every element in the array 1 to the right to make space at [0].\nWith a linked list you can insert data items anywhere in the list without having to shift the entire list. To do this you have to tell the next and previous node to point to this new node.\nLet’s say you have an array that grows every day. One day the array has 5000 elements in it. To insert an item at [0] you’ll have to move 5000 elements.\nWith a linked list you do not have to shift any items, you can insert them. This makes them useful for lists which may grow in size at an expeditious rate.\nLinked lists are scalable and adaptable.\nWe call the “forwards” and “backwards” elements of a node the pointers of the node. Nodes have 2 / 3 elements in them depending on whether it is a singly linked list or a doubly linked list.\nSingly Linked Lists A Node of a Singly Linked List A Singly Linked List has a data element to it and a pointer pointing to the next node. When the pointer is pointing at nothing we say that it is pointing at Null.\n2 components make up the singly linked list node — the data and the pointer.\nSingly linked lists cannot point backwards as they do not have a “backwards” pointer.\nA pointer does not store any data other than where the next node is. It is literally a pointer. 2 nodes in a linked list. One of them is correctly pointing to NULL. A new node has been added to show what the singly linked list looks like with more than 1 node in it. 3 nodes in a linked list, with a header and tail pointer. Depending on the implementation a linked list could also have 2 special pointers — head and tail.\nThe head pointer points to the very first node in the linked list. The tail pointer points to the last node in the linked list.\nIf you only have one node in the linked list the convention is for head to point to it and for tail to point to null. Although this is entirely up to the programmers and in some cases head and tail can point to the same singular node.\nProgrammers create special functions for linked lists to make them mroe usable. These functions are:\n node.data = get data from current node node.next = go to next node  Doubly Linked List A doubly linked list is a singly linked list that has a “backwards” component. A node in a doubly linked list with 3 components Each node in a doubly linked list has 3 components. A backwards pointer, a data element and a forwards pointer. 2 nodes in a doubly linked list. Both nodes are correctly pointing at NULL. There are header and tail pointers in this linked list. Like with singly linked lists, doubly linked lists have special functions. These functions are:\n node.data = get data from current node node.next = go to next node node.prev = go to previous node  If you use node.prev on the head node then the function will error or produce a NULL value. If you use node.next on the tail node then the function will error or produce a NULL value.\nTraversing Linked Lists Something we want to do a lot of with linked lists is to traverse them. Go up and down the linked list.\nThe first thing we need to do is to define where we start. Well, the starting point of the linked list (head) is a good place.\nNow we want a loop that goes through the entire list. We want to go through every single node until the currently selected node is “NULL” or None in Python. Once we hit a “None” node we know we are at the end.\nNow we want to do something with our linked list as we traverse it. Let’s print every data element in every node in our linked list.\nNow to actually move to the next node we use the node.next function:\nThe notation of:\nis called dot notation because we are calling the linked list’s function “next”. We will see how to program a linked list shortly.\nThe time complexity to search and traverse through linked lists is O(n). If you do not understand big O notation I highly recommend this article: [\nAll You Need to Know About Big O Notation [Python Examples]\nBy the end of this article, you’ll thoroughly understand Big O notation. You’ll also know how to use it in the real world, and even the mathematics behind it! In computer science, time complexity is the computational complexity that describes the amount of time it takes to run an algorithm. Big O …\nBrandon SkerrittBrandon’s Blog\n](https://skerritt.blog/big-o/)\nProgramming Linked Lists Linked Lists aren’t available in most languages so we have to program it ourselves.\nBecause a node will have the same functions and look the same across our linked list it is best to create this as a class.\nA class is a template for an object. You can create many objects from one class.\nLet’s design the linked list in Java.\nYou can apply 3 methods to this node using the dot notation:\nThe class has a “constructor” method which runs every time we make a new node. This initialises the node for us. The constructor method sets the next and previous pointers to point to “null”. It then sets the data to “i” which is what the user wants to put into the node.\nIf we wanted to make a single node we just need to write this code:\nThis creates an instance of the Node class and provides the number “5” to it as the data element of that node.\nNow of course having one singular node isn’t useful at all. We want to add more nodes to the linked list.\nRemember that example from earlier where adding an element to the front of an array requires shifting every element to the right by 1?\nWe’re going to show how this is easier done using linked lists.\nIn order to add a new node to the front of the list we will need a method (function) that does this\nBefore we can add a node to the front we first must create a node with the value we want: A doubly linked list already exsists with data 15 and 14. We create a new node with data Value that is not currently connected to the linked list; as such both pointers point to NULL. Now from our definition of the node class earlier the node’s functions node.next and node.prev points to null. Let’s change that:\nWe have not updated the head pointer, so it still points to the head of the linked list which is what we want to make the second node in the linked list. We make the node.next pointer point at where the head pointer is pointing at. We begin to attach the new node to the rest of the linked list. We tell the forward component to point at where head is pointing at. Because we are inserting a new node at the front of the linked list we will need to update the head pointer soon. First, we’ll define where the new nodes previous pointer points to.\nWe actually didn’t need to update newNode.prev to be null because it’s already done in the Node class; however to make things clear the code has been put there. Since we defined both pointers of a doubly linked list node to point to NULL nothing has changed. The code has been put here for extra clarity. This has not changed the linked list. Now we need to update the second node, the node that the head pointer is still pointing at. It needs to know that node.previous points to an actual node now and not just null.\nIf the head pointer is not pointing at anything as the linked list has not been created yet then we do not need to update the node. The second node (head node) has been updated so the previous component points at our new node. If the head pointer is pointing at a node then inform that node that it’s .prev function points to the new node we have just inserted.\nElse if the head is pointing at nothing make the tail the newNode. Earlier we talked about whether a singular node has a head or tail pointer pointing at it. This is the part where the programmer decides. Here we have elected to make the singular node the tail and the head at the same time.\nWe now just need to update the head pointer to point to the new head of the linked list: The new node has been inserted at the head of the linked list. We have just updated the head pointer to point to the new head. We can also delete a node at the front of the linked list in a similar fashion:\nWe assume here that curr is a pointer that points to any node in the linked list.\nWe then want to set curr to head, since we’re deleting the head node: The curr pointer is pointing at the same place the head pointer is. We want to make sure that head is pointing at something. curr is not equal to null as there is a node there.\nWe move the head pointer 1 to the right. We have moved the head pointer to the right We also make head.prev into null.\nNow we remove curr.next’s pointer The Curr node is completely disconnected from the linked list. Now we have this node sitting in a space doing nothing. We return the node in case we want to do something else with it.\nAnd that’s it! The node is no longer connected to the linked list, thus making it ‘deleted’.\nInserting Items into Linked Lists The true power of a linked list is being able to insert items anywhere in them.\nInserting an item anywhere in a linked list is similar to inserting an item at the head. You just change a few variables, the idea is still the same.\nWhenever we want to insert a new node, we just have to tell the node what the next and previous nodes are.\nSearching a Linked List Linked lists are normally sorted. Items can be inserted anywhere in a linked list, so it makes sense to put them in the right place. If you have a linked list with data of 3, 4, 6 the programmer would likely put the new node containing 5 between 4 and 6. But this is entirely down to the programmer.\nWe could use binary search to search the list. But, this is a bad idea. We don’t know where the middle of a linked list is. Everytime we wanted to find the middle we would have to count every single node in the list and half that by 2.\nWe can use a modified version of sequential search to search a linked list.\nAssume the linked list is sorted in ascending order. we can use this information to make sequential search faster.\nSince the linked list is sorted sequentially we know that the nodes in the linked list go in some order, like 1, 2, 3, 4, 5 for example. If node.data is more than the key (what we’re looking for) we know it’s not in the list, because it is sorted.\nSo if we wanted to find 2.5 we would do this:\n1 is selectedis 1 goal? - nois 1  2.5? no2 is selectedis 2 goal? nois 2  2.5? no3 is selectedis 3 goal? nois 3  2.5? yes - we can assume 2.5 is not in list and thus end the search here\nThere are many search algorithms out there. But most of the time if you know a little bit of information about the data you can change a search algorithm to be more efficient. In general, binary search is extremely effective but here it’s not so good. Don’t use an algorithm because Stack Overflow says that it is the fastest, best algorithm for the job.\nAlgorithms are like programming languages. We all have our favourites and sometimes we say that one programming language is better than another (Python, I love you). But at the end of the day it would be foolish and naive to say that one programming language is better than all the others. Use the right tool for the job, and change it if you want to!\nBlockchains Back to blockchain technology. Earlier I said:\n The blockchain is an immutable, ordered, back-linked list of blocks of transactions.\n So let’s work through this.\nThe blockchain is immutable. You cannot in theory change the blockchain. It is possible but it is very very hard to do, especially to a blockchain such as Bitcoin’s blockchain.\nThe blockchain is ordered in terms of most frequent transaction is “on top” of the chain. Or most frequent transaction is furthest to the right.\nThe blockchain is linked “back” referring to the previous block in the chain. Every block refers to the block behind it.\nEach block is a transaction.\nYou should now have a firm understanding of linked lists and how they work. You should also understand the linked list part of the blockchain.\nIf you liked this article, connect with me! LinkedIn | Twitter | Website | Newsletter\n",
  "wordCount" : "2428",
  "inLanguage": "en",
  "datePublished": "2019-10-10T16:19:24Z",
  "dateModified": "2019-10-10T16:19:24Z",
  "author":{
    "@type": "Person",
    "name": "Bee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://polymath.cloud/you-dont-understand-blockchain-unless-you-understand-this-simple-data-structure/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Polymath.cloud",
    "logo": {
      "@type": "ImageObject",
      "url": "https://polymath.cloud/favicon.ico"
    }
  }
}
</script>



</head>

<body class="">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://polymath.cloud" accesskey="h">Polymath.cloud</a>
            <span class="logo-switches">
                <span class="theme-toggle">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://polymath.cloud/archives" title="Archive">
                    <span>
                        Archive
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/search/" title="Search">
                    <span>
                        Search
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/tags/" title="Tags">
                    <span>
                        Tags
                    </span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      How linked lists work with an application to Blockchain
    </h1>
    <div class="post-meta">

October 10, 2019&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Bee

    </div>
  </header> 

  <div class="post-content">
<p>The blockchain is an immutable, ordered, back-linked list of blocks of transactions. If you want to truly understand blockchain you need to understand linked lists.</p>
<p>Linked Lists are a linear collection of data elements. Linearty in a linked list is not defined by each element’s physical placement. Instead each data node in a linked list points to one or two other nodes in the linked list.</p>
<p>With an array such as [1, 2, 3] you know that the element 1 is at position [0] and element 2 is at position [1].</p>
<p>The <strong>physical</strong> placement of each element defines the linearty of the array. This does not happen with linked lists.</p>
<p>Nodes make up elements in linked lists. Every node has a data section to it. As well as data, each node has a “forwards” and “backwards” section pointing to the previous and next node in the list.</p>
<p>In an array if you want to insert an item at [0] you need to shift every element in the array 1 to the right to make space at [0].</p>
<p>With a linked list you can insert data items anywhere in the list without having to shift the entire list. To do this you have to tell the next and previous node to point to this new node.</p>
<p>Let’s say you have an array that grows every day. One day the array has 5000 elements in it. To insert an item at [0] you’ll have to move 5000 elements.</p>
<p>With a linked list you do not have to shift any items, you can insert them. This makes them useful for lists which may grow in size at an expeditious rate.</p>
<p>Linked lists are scalable and adaptable.</p>
<p>We call the “forwards” and “backwards” elements of a node the pointers of the node. Nodes have 2 / 3 elements in them depending on whether it is a singly linked list or a doubly linked list.</p>
<h3 id="singly-linked-lists">Singly Linked Lists<a hidden class="anchor" aria-hidden="true" href="#singly-linked-lists">#</a></h3>
<p><img src="https://cdn-images-1.medium.com/max/800/1*tZeQ7c4s8mIdgQPFs6DpPw.png" alt="">A Node of a Singly Linked List
A Singly Linked List has a data element to it and a pointer pointing to the next node. When the pointer is pointing at nothing we say that it is pointing at Null.</p>
<p>2 <strong>components</strong> make up the singly linked list node — the data and the pointer.</p>
<p>Singly linked lists cannot point backwards as they do not have a “backwards” pointer.</p>
<p>A pointer does not store any data other than where the next node is. It is literally a pointer.
<img src="https://cdn-images-1.medium.com/max/800/1*d3f_qh9xp1JCGvBM1yRtrQ.png" alt="">2 nodes in a linked list. One of them is correctly pointing to NULL.
A new node has been added to show what the singly linked list looks like with more than 1 node in it.
<img src="https://cdn-images-1.medium.com/max/800/1*5TjzOrO0_kOx2eFXf0_rKQ.png" alt="">3 nodes in a linked list, with a header and tail pointer.
Depending on the implementation a linked list could also have 2 special pointers — head and tail.</p>
<p>The head pointer points to the very first node in the linked list. The tail pointer points to the last node in the linked list.</p>
<p>If you only have one node in the linked list the convention is for head to point to it and for tail to point to null. Although this is entirely up to the programmers and in some cases head and tail can point to the same singular node.</p>
<p>Programmers create special functions for linked lists to make them mroe usable. These functions are:</p>
<ul>
<li>node.data = get data from current node</li>
<li>node.next = go to next node</li>
</ul>
<h3 id="doubly-linked-list">Doubly Linked List<a hidden class="anchor" aria-hidden="true" href="#doubly-linked-list">#</a></h3>
<p>A doubly linked list is a singly linked list that has a “backwards” component.
<img src="https://cdn-images-1.medium.com/max/800/1*AdjEZlPyCe-yXhXwFhUrJA.png" alt="">A node in a doubly linked list with 3 components
Each <strong>node</strong> in a doubly linked list has 3 <strong>components</strong>. A backwards pointer, a data element and a forwards pointer.
<img src="https://cdn-images-1.medium.com/max/800/1*WBc-5orIYMBzOvwzAjKs1Q.png" alt="">2 nodes in a doubly linked list. Both nodes are correctly pointing at NULL. There are header and tail pointers in this linked list.
Like with singly linked lists, doubly linked lists have special functions. These functions are:</p>
<ul>
<li>node.data = get data from current node</li>
<li>node.next = go to next node</li>
<li>node.prev = go to previous node</li>
</ul>
<p>If you use node.prev on the head node then the function will error or produce a NULL value. If you use node.next on the tail node then the function will error or produce a NULL value.</p>
<h3 id="traversing-linked-lists">Traversing Linked Lists<a hidden class="anchor" aria-hidden="true" href="#traversing-linked-lists">#</a></h3>
<p>Something we want to do a lot of with linked lists is to traverse them. Go up and down the linked list.</p>
<p>The first thing we need to do is to define where we start. Well, the starting point of the linked list (head) is a good place.</p>
<p>Now we want a loop that goes through the entire list. We want to go through every single node until the currently selected node is “NULL” or None in Python. Once we hit a “None” node we know we are at the end.</p>
<p>Now we want to do something with our linked list as we traverse it. Let’s print every data element in every node in our linked list.</p>
<p>Now to actually move to the next node we use the node.next function:</p>
<p>The notation of:</p>
<p>is called <strong>dot</strong> notation because we are calling the linked list’s function “next”. We will see how to program a linked list shortly.</p>
<p><a href="https://skerritt.blog/big-o/">The time complexity to search and traverse through linked lists is O(n). If you do not understand big O notation I highly recommend this article:</a>
[</p>
<p>All You Need to Know About Big O Notation [Python Examples]</p>
<p>By the end of this article, you’ll thoroughly understand Big O notation. You’ll
also know how to use it in the real world, and even the mathematics behind it! In computer science, time complexity is the computational complexity that
describes the amount of time it takes to run an algorithm. Big O …</p>
<p><img src="https://skerritt.blog/favicon.png" alt="">Brandon SkerrittBrandon&rsquo;s Blog</p>
<p><img src="/content/images/2019/10/Copy-of-Copy-of-Copy-of-Copy-of-Dynamic-Programming-with-Python-The-Ultimate-Guide-1.png" alt="">
](<a href="https://skerritt.blog/big-o/">https://skerritt.blog/big-o/</a>)</p>
<h3 id="programming-linked-lists">Programming Linked Lists<a hidden class="anchor" aria-hidden="true" href="#programming-linked-lists">#</a></h3>
<p>Linked Lists aren’t available in most languages so we have to program it ourselves.</p>
<p>Because a node will have the same functions and look the same across our linked list it is best to create this as a class.</p>
<p>A class is a template for an <strong>object</strong>. You can create many objects from one class.</p>
<p>Let’s design the linked list in Java.</p>
<p>You can apply 3 methods to this node using the dot notation:</p>
<p>The class has a “constructor” method which runs every time we make a new node. This initialises the node for us. The constructor method sets the next and previous pointers to point to “null”. It then sets the data to “i” which is what the user wants to put into the node.</p>
<p>If we wanted to make a single node we just need to write this code:</p>
<p>This creates an <strong>instance</strong> of the Node class and provides the number “5” to it as the data element of that node.</p>
<p>Now of course having one singular node isn’t useful at all. We want to add more nodes to the linked list.</p>
<p>Remember that example from earlier where adding an element to the front of an array requires shifting every element to the right by 1?</p>
<p>We’re going to show how this is easier done using linked lists.</p>
<p>In order to add a new node to the front of the list we will need a method (function) that does this</p>
<p>Before we can add a node to the front we first must create a node with the value we want:
<img src="https://cdn-images-1.medium.com/max/800/1*cwNAmCQNH3biOcA8WgpC7Q.png" alt="">A doubly linked list already exsists with data 15 and 14. We create a new node with data Value that is not currently connected to the linked list; as such both pointers point to NULL.
Now from our definition of the node class earlier the node’s functions node.next and node.prev points to null. Let’s change that:</p>
<p>We have not updated the head pointer, so it still points to the head of the linked list which is what we want to make the second node in the linked list. We make the node.next pointer point at where the head pointer is pointing at.
<img src="https://cdn-images-1.medium.com/max/800/1*WSxgCOxx3g1ULbYS27m8Uw.png" alt="">We begin to attach the new node to the rest of the linked list. We tell the forward component to point at where head is pointing at.
Because we are inserting a new node at the front of the linked list we will need to update the head pointer soon. First, we’ll define where the new nodes previous pointer points to.</p>
<p>We actually didn’t need to update newNode.prev to be null because it’s already done in the Node class; however to make things clear the code has been put there.
<img src="https://cdn-images-1.medium.com/max/800/1*WSxgCOxx3g1ULbYS27m8Uw.png" alt="">Since we defined both pointers of a doubly linked list node to point to NULL nothing has changed. The code has been put here for extra clarity. This has <strong>not</strong> changed the linked list.
Now we need to update the second node, the node that the head pointer is still pointing at. It needs to know that node.previous points to an actual node now and not just null.</p>
<p>If the head pointer is not pointing at anything as the linked list has not been created yet then we do not need to update the node.
<img src="https://cdn-images-1.medium.com/max/800/1*3Vi7Omq3KWb0q9JbnBU1BQ.png" alt="">The second node (head node) has been updated so the previous component points at our new node.
If the head pointer is pointing at a node then inform that node that it’s .prev function points to the new node we have just inserted.</p>
<p>Else if the head is pointing at nothing make the tail the newNode. Earlier we talked about whether a singular node has a head or tail pointer pointing at it. This is the part where the programmer decides. Here we have elected to make the singular node the tail and the head at the same time.</p>
<p>We now just need to update the head pointer to point to the new head of the linked list:
<img src="https://cdn-images-1.medium.com/max/800/1*1oa2rx4xWSKxij6Y6EcTgQ.png" alt="">The new node has been inserted at the head of the linked list. We have just updated the head pointer to point to the new head.
We can also delete a node at the front of the linked list in a similar fashion:</p>
<p>We assume here that curr is a pointer that points to any node in the linked list.</p>
<p>We then want to set curr to head, since we’re deleting the head node:
<img src="https://cdn-images-1.medium.com/max/800/1*X1gmq_aVCT4lY6usR96JgA.png" alt="">The curr pointer is pointing at the same place the head pointer is.
We want to make sure that head is pointing at something. curr is not equal to null as there is a node there.</p>
<p>We move the head pointer 1 to the right.
<img src="https://cdn-images-1.medium.com/max/800/1*Cf6j4zPjrkEeIvvfdbPwow.png" alt="">We have moved the head pointer to the right
We also make head.prev into null.</p>
<p>Now we remove curr.next’s pointer
<img src="https://cdn-images-1.medium.com/max/800/1*2TQS4dmYjQji0quKcQR4uQ.png" alt="">The Curr node is completely disconnected from the linked list.
Now we have this node sitting in a space doing nothing. We return the node in case we want to do something else with it.</p>
<p>And that’s it! The node is no longer connected to the linked list, thus making it ‘deleted’.</p>
<h3 id="inserting-items-into-linked-lists">Inserting Items into Linked Lists<a hidden class="anchor" aria-hidden="true" href="#inserting-items-into-linked-lists">#</a></h3>
<p>The true power of a linked list is being able to insert items anywhere in them.</p>
<p>Inserting an item anywhere in a linked list is similar to inserting an item at the head. You just change a few variables, the idea is still the same.</p>
<p>Whenever we want to insert a new node, we just have to tell the node what the next and previous nodes are.</p>
<h3 id="searching-a-linked-list">Searching a Linked List<a hidden class="anchor" aria-hidden="true" href="#searching-a-linked-list">#</a></h3>
<p>Linked lists are normally sorted. Items can be inserted anywhere in a linked list, so it makes sense to put them in the right place. If you have a linked list with data of 3, 4, 6 the programmer would likely put the new node containing 5 between 4 and 6. But this is entirely down to the programmer.</p>
<p>We could use binary search to search the list. But, this is a bad idea. We don’t know where the middle of a linked list is. Everytime we wanted to find the middle we would have to count every single node in the list and half that by 2.</p>
<p>We can use a modified version of sequential search to search a linked list.</p>
<p>Assume the linked list is sorted in ascending order. we can use this information to make sequential search faster.</p>
<p>Since the linked list is sorted sequentially we know that the nodes in the linked list go in some order, like 1, 2, 3, 4, 5 for example. If node.data is more than the key (what we’re looking for) we know it’s not in the list, because it is sorted.</p>
<p>So if we wanted to find 2.5 we would do this:</p>
<p>1 is selectedis 1 goal? - nois 1 &gt; 2.5? no2 is selectedis 2 goal? nois 2 &gt; 2.5? no3 is selectedis 3 goal? nois 3 &gt; 2.5? yes - we can assume 2.5 is not in list and thus end the search here</p>
<p>There are many search algorithms out there. But most of the time if you know a little bit of information about the data you can change a search algorithm to be more efficient. In general, binary search is extremely effective but here it’s not so good. Don’t use an algorithm because Stack Overflow says that it is the fastest, best algorithm for the job.</p>
<p>Algorithms are like programming languages. We all have our favourites and sometimes we say that one programming language is better than another (Python, I love you). But at the end of the day it would be foolish and naive to say that one programming language is better than all the others. Use the right tool for the job, and change it if you want to!</p>
<h3 id="blockchains">Blockchains<a hidden class="anchor" aria-hidden="true" href="#blockchains">#</a></h3>
<p><img src="https://cdn-images-1.medium.com/max/800/1*qYKsqQ6aV-DgFD0REfcnig.png" alt="img">
Back to blockchain technology. Earlier I said:</p>
<blockquote>
<p><em>The blockchain is an immutable, ordered, back-linked list of blocks of transactions.</em></p>
</blockquote>
<p>So let’s work through this.</p>
<p>The blockchain is immutable. You cannot in theory change the blockchain. It is possible but it is very very hard to do, especially to a blockchain such as Bitcoin’s blockchain.</p>
<p>The blockchain is ordered in terms of most frequent transaction is “on top” of the chain. Or most frequent transaction is furthest to the right.</p>
<p>The blockchain is linked “back” referring to the previous block in the chain. Every block refers to the block behind it.</p>
<p>Each block is a transaction.</p>
<p>You should now have a firm understanding of linked lists and how they work. You should also understand the linked list part of the blockchain.</p>
<h3 id="if-you-liked-this-article-connect-with-me">If you liked this article, connect with me!<a hidden class="anchor" aria-hidden="true" href="#if-you-liked-this-article-connect-with-me">#</a></h3>
<p><a href="https://www.linkedin.com/in/brandonls/">LinkedIn</a> | <a href="https://twitter.com/brandon_skerrit">Twitter</a> | <a href="http://brandonskerritt.github.io/">Website</a> | <a href="https://upscri.be/885736-2/">Newsletter</a></p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://polymath.cloud/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://polymath.cloud/tags/university/">University</a></li>
    </ul>






<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on twitter"
        href="https://twitter.com/intent/tweet/?text=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain&amp;url=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f&amp;hashtags=University%2cComputerScience">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f&amp;title=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain&amp;summary=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain&amp;source=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f&title=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on whatsapp"
        href="https://api.whatsapp.com/send?text=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain%20-%20https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How linked lists work with an application to Blockchain on telegram"
        href="https://telegram.me/share/url?text=How%20linked%20lists%20work%20with%20an%20application%20to%20Blockchain&amp;url=https%3a%2f%2fpolymath.cloud%2fyou-dont-understand-blockchain-unless-you-understand-this-simple-data-structure%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://polymath.cloud">Polymath.cloud</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://polymath.cloud/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
