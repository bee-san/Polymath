<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Hash functions explained for non cryptographers | Polymath.cloud</title>

<meta name="keywords" content="University, Computer Science, Infosec" />
<meta name="description" content="A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let&rsquo;s say the hash function returns &ldquo;aBc67D&rdquo; for the message &ldquo;I love dogs&rdquo;. This function should not return the same &ldquo;aBc67D&rdquo; for &ldquo;Donuts are cool&rdquo;.
Hashing algorithms have 3 requirements:
 A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify. If you change one single bit anywhere in the message, the outputted string must look completely different.">
<meta name="author" content="Bee">
<link rel="canonical" href="https://polymath.cloud/hash-functions/" />
<link href="https://polymath.cloud/assets/css/stylesheet.min.94a69f3d0b70cac76c6d6f7dfecc9f91f2319ec73d54be960b0d3624fa5a25e2.css" integrity="sha256-lKafPQtwysdsbW99/syfkfIxnsc9VL6WCw02JPpaJeI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://polymath.cloud/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://polymath.cloud/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://polymath.cloud/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://polymath.cloud/apple-touch-icon.png">
<link rel="mask-icon" href="https://polymath.cloud/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />




<style>
    td, th {
    border: thin solid #999 !important;
    padding: 12px 15px;
}

thead tr {
    background-color: #009879;
    color: #ffffff;
    text-align: left;
}

table {
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 0.9em;
    font-family: sans-serif;
    min-width: 400px;
    overflow: auto;
    display: table;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
}

tbody tr {
    border-bottom: thin solid #dddddd;
}


tbody tr:last-of-type {
    border-bottom: 2px solid #009879;
}

tbody td.active-item {
    font-weight: bold;
    color: #009879;
}

tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
    }


body.dark tbody tr:nth-of-type(even) {
    background-color: #383838;
}


img {
    display: block;
    margin: auto;
    text-align: center;
}

</style>
<meta property="og:title" content="Hash functions explained for non cryptographers" />
<meta property="og:description" content="A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let&rsquo;s say the hash function returns &ldquo;aBc67D&rdquo; for the message &ldquo;I love dogs&rdquo;. This function should not return the same &ldquo;aBc67D&rdquo; for &ldquo;Donuts are cool&rdquo;.
Hashing algorithms have 3 requirements:
 A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify. If you change one single bit anywhere in the message, the outputted string must look completely different." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://polymath.cloud/hash-functions/" />
<meta property="article:published_time" content="2019-11-19T01:47:38+00:00" />
<meta property="article:modified_time" content="2019-11-19T01:47:38+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hash functions explained for non cryptographers"/>
<meta name="twitter:description" content="A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let&rsquo;s say the hash function returns &ldquo;aBc67D&rdquo; for the message &ldquo;I love dogs&rdquo;. This function should not return the same &ldquo;aBc67D&rdquo; for &ldquo;Donuts are cool&rdquo;.
Hashing algorithms have 3 requirements:
 A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify. If you change one single bit anywhere in the message, the outputted string must look completely different."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hash functions explained for non cryptographers",
  "name": "Hash functions explained for non cryptographers",
  "description": "A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let\u0026amp;rsquo;s say the hash function returns …",
  "keywords": [
    "University", "Computer Science", "Infosec"
  ],
  "articleBody": "A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let’s say the hash function returns “aBc67D” for the message “I love dogs”. This function should not return the same “aBc67D” for “Donuts are cool”.\nHashing algorithms have 3 requirements:\n A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify. If you change one single bit anywhere in the message, the outputted string must look completely different. You must avoid collisions.  For the first point, the algorithms have to be fast. Hashing algorithms are often used by much slower algorithms (such as RSA) to speed up the algorithm. As a side note, most hashing algorithms are designed to be one-way functions.\nThe algorithm has to be fast, but it does not have to be efficient. Efficient hashing algorithms make causing collisions easier for attacks. Hashing algorithms need to be resistant towards “pre-image attacks\". That is, given a hash, it should be extremely difficult to calculate retrace the deterministic steps taken to reproduce the value that created the hash (i.e. the pre-image).\nFor the second point, if using SHA-5 and we input:\nabc = a9993e364706816aba3e25717850c26c9cd0d89d  An important feature we want is that if we were to change the original string even slightly by say one letter the entire outputted hash has to change. If we input “abd” we get:\nabd = cb4cc28df0fdbe0ecf9d9662e294b118092a5735  So the idea of randomness here is that the first hash does not look anything like the second hash despite us only changing 1 letter. In fact, with some code:\nWe find out that a and b are 0% similar (using the Hamming Distance). This is called the Avalanche effect. When the input changes slightly, the output changes significantly.\nFor the third point, this is the donut/dogs example above. Sometimes, it’s okay to not avoid collisions because there are billions of different messages and a fixed length hash message. But, by not avoiding collisions other people can artificially make a message with the same hash as another file and this is an issue - because it’s a fake message.\nLet’s walk through how SHA-1, an old hashing algorithm, works in detail. Although all hashing algorithms work differently and SHA-1 isn’t used in the real world anymore, seeing how SHA-1 works in detail will enable us to generalise how hashing algorithms work.\n SHA-1 SHA-1 takes a bit string of length less than 264 bits and produces a 160-bit hash value known as the message digest. Note: I will be using hexadecimal numbering for brevity. Hashing algorithms never take a message of size X, and return a message of size X. They always ‘compress’ and create a digest of the message. Remember rule 1 for hashing algorithms from earlier? We want hashing algorithms to be fast. Producing large messages is not fast.\nSHA-1 was published in 1993 by NIST, but was developed by the NSA (yes, that NSA). Not much is known about the history of SHA-1, so I apologise for not including history here.\nSuppose we want to encode the message ‘abc’ using SHA-1. We start off by converting it into binary:\n$$ abc = 01100001 01100010 01100011$$\nSHA-1 starts with an internal state. Let’s say our internal state of SHA-1 is:\n$$ h_0, h_1, h_2, h_3, h_4$$\nThe internal state size is exactly the same as the length it produces (160). So each internal state H has 160/5 = 32-bit words which is 4 bytes each. We split it into chunks because it’s easier to calculate. We start by initializing these internal states with five random strings of hex characters:\n$$H_0 = 67DE2A01$$\n$$H_1 = BB03E28C$$\n$$H_2 = 011EF1DC$$\n$$H_3 = 9293E9E2$$\n$$H_4 = CDEF23A9$$\nThe message is then padded by appending a 1, followed by enough 0s until the message is 448 bits. The length of the message represented by 64 bits is then added to the end, producing a message that is 512 bits long. https://brilliant.org/wiki/secure-hashing-algorithms/ The padded input obtained above, $M$, is then divided into 512-bit chunks and each chunk is further divided into sixteen 32-bit words, $W_0, …, W_15$. In the case of ‘abc’ there is only one chunk, as the message is less than 512-bits total.\nFor each chunk, begin the 80 iterations, $i$, necessary for hashing (80 is the determined number for SHA-1), and execute the following steps on each chunk, $M_n$:\nFor iterations 16 through to 79, where $16 \\le i \\le 79$, perform the following operation:\n$$W(i) = S^1(W(i-3) \\oplus W(i-8) \\oplus W(i-14) \\oplus W(i-16))$$\nThe symbol $\\oplus $ is XOR which is exclusive or. The resultant is True (1) if and only if either the left hand side or right hand side is 1, but not both. Truth table for XOR As an example, when $i$ is 16, the words chosen are W(13), W(8), W(2), W(0) and the output is a new word, W(16), so performing the XOR operation on these words gives us: Now, the circular shift operation on the word by bits, being an integer between and, is defined by\n$$S^n(X) = (X « n) OR (X» 32 - n)$$\nwhere $X « n$ is the left-shift operation, obtained by discarding the leftmost $n$ bits of $X$ and padding the result with zeroes on the right. If you don’t know what the logic symbols mean, I’ve written an article explaining them here.\n$X » 32 - n$ is the right-shift operation obtained by discarding the $n$ rightmost bits of $x$ and padding the result with $n$ zeroes on the left. Thus $S^n(X)$ is equivalent to a circular shift of by positions, and in this case, the circular left-shift is used. A left shift $S^n(W(i))$, where $W(i)$ is $10010$ would produce $01001$ as the rightmost bit, 0, is shifted to the left side of the string. Therefore $W(16)$ would end up being:\n$$ W(16) = 11000010 11000100 11000111 00000000$$\nNow store the hash values defined in step 1 in the following variables:\n$$A = H_0$$\n$$B = H_1$$\n$$C = H_2$$\n$$D = H_3$$\n$$E = H_4$$\nFor 80 iterations, where $0 \\le i \\geq 79$ compute:\n$$TEMP = S^5 * (A) + f(i; B, C, D) + E + W(i) + K(i)$$\nWe have to use a which takes in our data and a bit of the message and turns it into another set of h values.\nA sequence of functions are used in SHA-1 depending on the value of $i$ and on three 32-bit words, B, C, and D, in order to produce a 32-bit output.\nThe following equations describe these logical functions.\n$f(i; B, C, D) = (B \\land C) \\vee ((\\not B) \\land D)$ for $0 \\geq i \\geq 19$\n$ f(i; B, C, D) = B \\oplus C \\oplus D$ for $20 \\geq i \\geq 39$\n$ f(i; B, C, D) = (B \\land C) \\vee (B \\land D) \\vee (C \\land D)$ for $40 \\geq i \\geq 59$\n$f(i; B, C, D) = B \\oplus C \\oplus D$ for $60 \\geq i \\geq 79$\nA sequence of constant words $K(0), K(1), … , K(79)$ is used in the SHA-1. In hex, these are given:\n $K(i) = 5A827999$ for $0 $K(i) = 6ED9EBA1$ for $20 $K(i) = 8F1BBCDC$ for $40 $K(i) = CA62C1D6$ for $60 Reassign the following values:\n$$ E = D$$\n$$D = C$$\n$$ C = S^30 (B)$$\n$$B = A$$\n$$ A = TEMP$$\nStore the result of the chunk’s hash to the overall hash value of all chunks as shown below, and proceed to execute the next chunk:\n$$H_0 = H_0 + A$$\n$$H_1 = H_1 + B$$\n$$H_2 = H_2 + C$$\n$$H_3 = H_3 + D$$\n$$H_4 = H_4 + E$$\nAs a final step, when all chunks have been processed, the message digest is represented as the 160-bit string comprised of the OR logical operator and the 5 hashed values:\n$$H = S^128 (H_0) \\vee S^96 (H_2) \\vee S^32(H_3) \\vee H_4$$\n Sha-1 sucks SHA-1 was broken quite a few years ago. By broken, I mean that it’s possible to artificially create collisions. That is, given a document with an SHA-1 hash of “cb4cc28df0fdbe0ecf9d9662e294b118092a5735” it is possible to produce a different document that has the **same **hash.\nThis article used SHA-1 because it’s relatively easy to explain when compared to non-broken hash functions such as SHA-5. If you want to learn more about why you shouldn’t use SHA-1, read this article.\nAs a side note, do not try to implement SHA-1 yourself. Remember Scheiner’s rule:\n “Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can’t break.”\n While your implementation SHA-1 may appear to work to you, it may have some underlying issue that you didn’t spot. It’s always best to use implementations created and monitored by the community (open source).\n Breaking hashes MD5 was a pretty popular hashing algorithm which produced 128-bit outputs. It is suspectible to a birthday attack.\nBirthday attacks are formulated on the birthday problem. If there are 23 people in a room, there is a 50% chance two of them will share the same birthday. If there are 70 people in a room, this is a 99.9% chance 2 people share the same birthday.\nThis comes from what is called the pigeonhole principle. If you have 9 pigeonholes (boxes to put pigeons in) and 10 pigeons, 2 pigeons will have to share the same hole. In fact, MD5 is so weak to collision resistance that a simple, household 2.4GHz Pentium Processor can compute artificial hash collisions within seconds. Moreover, its extensive usage in the earlier days of the current web has created tons of leaked MD5 pre-images online that can be found with a simple Google search of their hash.\n Conclusion The 3 rules to hashing algorithms are:\n A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify. If you change one single bit anywhere in the message, the outputted string must look completely different. You must avoid collisions.  As we saw with SHA-1, it uses a compressor function to take a message and turn that message into a much smaller, hashed version. SHA-1 isn’t used in the real world anymore, and it’s not secure in the sense that collisions can be created. Although it’s a nice historical example of how hashing algorithms work.\nFor more on SHA-1, check out the official document describing it here. If you’re interested in what hash functions are used now (especially in cryptocurrencies, as well as the attacks on them and the differences this article is very good.\nHey 👋 Want to subscribe to my blog and stay up to date with posts similar to this one? Subscribe to my email list below. I won’t spam you. I will only send you posts similar to this one 😊✨\n#myemail { background-color: #f0f0f0; color: black; padding: 15px; border-radius: 25px; width: 80%; margin: 0 auto; } #little { color: grey; font-size: 10px; } #email { width: 100%; padding: 10px; } #submit { width: 100%; background: rgb(36,255,204); } #gdpr { width: 15px; height: 15px; }  At least this isn’t a full screen pop up! 😅  Sign up now and get:   A free 202 page book on algorithmic design paradigms A free 107 page book on employability skills And much more to help you become an awesome developer!  Email\nGDPR: I consent to receive promotional emails about your products and services. HP\nOne click unsubscribe anytime.\nIf you’re feeling extra generous, I have a PayPal  and even a Patreon. I’m a university student who writes these blogs in their spare time. This blog is my full time job, so any and all donations are appreciated!\n",
  "wordCount" : "1969",
  "inLanguage": "en",
  "datePublished": "2019-11-19T01:47:38Z",
  "dateModified": "2019-11-19T01:47:38Z",
  "author":{
    "@type": "Person",
    "name": "Bee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://polymath.cloud/hash-functions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Polymath.cloud",
    "logo": {
      "@type": "ImageObject",
      "url": "https://polymath.cloud/favicon.ico"
    }
  }
}
</script>



</head>

<body class="">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://polymath.cloud" accesskey="h">Polymath.cloud</a>
            <span class="logo-switches">
                <span class="theme-toggle">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://polymath.cloud/archives" title="Archive">
                    <span>
                        Archive
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/search/" title="Search">
                    <span>
                        Search
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/tags/" title="Tags">
                    <span>
                        Tags
                    </span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Hash functions explained for non cryptographers
    </h1>
    <div class="post-meta">

November 19, 2019&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Bee

    </div>
  </header> 

  <div class="post-content">
<p>A hash function takes a message, m, and returns a pseudo-random string of letters/numbers which should be unique to that message. Let&rsquo;s say the hash function returns &ldquo;aBc67D&rdquo; for the message &ldquo;I love dogs&rdquo;. This function should not return the same &ldquo;aBc67D&rdquo; for &ldquo;Donuts are cool&rdquo;.</p>
<p>Hashing algorithms have 3 requirements:</p>
<ol>
<li>A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify.</li>
<li>If you change one single bit anywhere in the message, the outputted string must look completely different.</li>
<li>You must avoid collisions.</li>
</ol>
<p>For the first point, the algorithms have to be fast. Hashing algorithms are often used by much slower algorithms (such as RSA) to speed up the algorithm. As a side note, most hashing algorithms are designed to be one-way functions.</p>
<p>The algorithm has to be fast, but it does not have to be <em>efficient</em>. Efficient hashing algorithms make causing collisions easier for attacks. Hashing algorithms need to be resistant towards &ldquo;<em>pre-image attacks</em>&quot;. That is, given a hash, it should be extremely difficult to calculate  retrace the deterministic steps taken to reproduce the value that  created the hash (i.e. the pre-image).</p>
<p>For the second point, if using <em><a href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_7.1.0/com.ibm.java.security.api.doc/jcefips/com/ibm/crypto/fips/provider/SHA5.html">SHA-5</a></em> and we input:</p>
<pre><code>abc = a9993e364706816aba3e25717850c26c9cd0d89d
</code></pre>
<p>An important feature we want is that if we were to change the original string even slightly by say one letter the entire outputted hash has to change. If we input &ldquo;<em>abd&rdquo;</em> we get:</p>
<pre><code>abd = cb4cc28df0fdbe0ecf9d9662e294b118092a5735
</code></pre>
<p>So the idea of randomness here is that the first hash does not look  anything like the second hash despite us only changing 1 letter. In fact, with some code:</p>
<p>We find out that a and b are 0% similar (using the <a href="https://www.wikiwand.com/en/Hamming_distance">Hamming Distance</a>). This is called the <a href="https://www.wikiwand.com/en/Avalanche_effect">Avalanche effect</a>. When the input changes slightly, the output changes significantly.</p>
<p>For the third point, this is the donut/dogs example above. Sometimes, it&rsquo;s okay to not avoid collisions because there are billions of different messages and a fixed length hash message. But, by not avoiding collisions other people can artificially make a message with the same hash as another file and this is an issue - because it&rsquo;s a fake message.</p>
<p>Let&rsquo;s walk through how SHA-1, an old hashing algorithm, works in detail. Although all hashing algorithms work differently and SHA-1 isn&rsquo;t used in the real world anymore, seeing how SHA-1 works in detail will enable us to generalise how hashing algorithms work.</p>
<hr>
<h2 id="sha-1">SHA-1<a hidden class="anchor" aria-hidden="true" href="#sha-1">#</a></h2>
<p>SHA-1 takes a bit string of length less than 264 bits and produces a 160-bit hash value known as the message digest. Note: I will be using hexadecimal numbering for brevity. Hashing algorithms never take a message of size X, and return a message of size X. They always &lsquo;compress&rsquo; and create a digest of the message. Remember rule 1 for hashing algorithms from earlier? We want hashing algorithms to be fast. Producing large messages is not fast.</p>
<p>SHA-1 was published in 1993 by NIST, but was developed by the NSA (yes, that NSA). Not much is known about the history of SHA-1, so I apologise for not including history here.</p>
<p>Suppose we want to encode the message &lsquo;abc&rsquo; using SHA-1. We start off by converting it into binary:</p>
<p>$$ abc = 01100001 01100010 01100011$$</p>
<p>SHA-1 starts with an internal state. Let&rsquo;s say our internal state of SHA-1 is:</p>
<p>$$ h_0, h_1, h_2, h_3, h_4$$</p>
<p>The internal state size is exactly the same as the length it produces  (160). So each internal state H has 160/5 = 32-bit words which is 4 bytes each. We split it into chunks because it&rsquo;s easier to calculate. We start by initializing these internal states with five random strings of hex characters:</p>
<p>$$H_0 = 67DE2A01$$</p>
<p>$$H_1 = BB03E28C$$</p>
<p>$$H_2 = 011EF1DC$$</p>
<p>$$H_3 = 9293E9E2$$</p>
<p>$$H_4 = CDEF23A9$$</p>
<p>The message is then padded by appending a 1, followed by enough 0s until the message is 448 bits. The length of the message represented by 64 bits is then added to the end, producing a message that is 512 bits long.
<img src="/content/images/2019/01/image-538.png" alt=""><a href="https://brilliant.org/wiki/secure-hashing-algorithms/">https://brilliant.org/wiki/secure-hashing-algorithms/</a>
The padded input obtained above, $M$, is then divided into 512-bit chunks and each chunk is further divided into sixteen 32-bit words, $W_0, &hellip;, W_15$. In the case of &lsquo;<em>abc</em>&rsquo; there is only one chunk, as the message is less than 512-bits total.</p>
<p>For each chunk, begin the 80 iterations, $i$, necessary for hashing (80 is the determined number for SHA-1), and execute the following steps on each chunk, $M_n$:</p>
<p>For iterations 16 through to 79, where $16 \le i \le 79$, perform the following operation:</p>
<p>$$W(i) = S^1(W(i-3) \oplus W(i-8) \oplus W(i-14) \oplus W(i-16))$$</p>
<p>The symbol $\oplus $ is <a href="https://www.wikiwand.com/en/Exclusive_or">XOR </a>which is exclusive or. The resultant is True (1) if and only if either the left hand side or right hand side is 1, but not both.
<img src="/content/images/2019/02/image-23.png" alt="">Truth table for XOR
As an example, when $i$ is 16, the words chosen are W(13), W(8), W(2), W(0) and the output is a new word, W(16), so performing the XOR operation on these words gives us:
<img src="/content/images/2019/01/image-539.png" alt="">
Now, the circular shift operation on the word by bits, being an integer between and, is defined by</p>
<p>$$S^n(X) = (X &laquo; n) OR (X&raquo; 32 - n)$$</p>
<p>where $X &laquo; n$ is the <strong>left-shift</strong> operation, obtained by discarding the leftmost $n$ bits of  $X$ and padding the result with zeroes on the right. If you don&rsquo;t know what the logic symbols mean, I&rsquo;ve written an article explaining them <a href="/mathematical-logic/">here</a>.</p>
<p>$X &raquo; 32 - n$ is the <strong>right-shift</strong> operation obtained by discarding the $n$ rightmost bits of $x$ and padding the result with $n$ zeroes on the left. Thus $S^n(X)$ is equivalent to a circular shift of by positions, and in this case, the circular left-shift is used.
<img src="/content/images/2019/01/image-540.png" alt="">
A left shift $S^n(W(i))$, where $W(i)$ is $10010$ would produce $01001$ as the rightmost bit, 0, is shifted to the left side of the string. Therefore $W(16)$ would end up being:</p>
<p>$$ W(16) = 11000010 11000100 11000111 00000000$$</p>
<p>Now store the hash values defined in step 1 in the following variables:</p>
<p>$$A = H_0$$</p>
<p>$$B = H_1$$</p>
<p>$$C = H_2$$</p>
<p>$$D = H_3$$</p>
<p>$$E = H_4$$</p>
<p>For 80 iterations, where $0 \le i \geq 79$ compute:</p>
<p>$$TEMP = S^5 * (A) + f(i; B, C, D) + E + W(i) + K(i)$$</p>
<p>We have to use a which takes in our data and a bit of the message and turns it into another set of h values.</p>
<p>A sequence of functions are used in SHA-1 depending on the value of $i$ and on three 32-bit words, B, C, and D, in order to produce a 32-bit output.</p>
<p>The following equations describe these logical functions.</p>
<p>$f(i; B, C, D) = (B \land C) \vee ((\not B) \land D)$ for $0 \geq i \geq 19$</p>
<p>$ f(i; B, C, D) = B \oplus C \oplus D$ for $20 \geq i \geq 39$</p>
<p>$ f(i; B, C, D) = (B \land C) \vee (B \land D) \vee (C \land D)$ for $40 \geq i \geq 59$</p>
<p>$f(i; B, C, D)  = B \oplus C \oplus D$ for $60 \geq i \geq 79$</p>
<p>A sequence of constant words $K(0), K(1), &hellip; , K(79)$ is used in the SHA-1. In hex, these are given:</p>
<p>     $K(i) = 5A827999$ for $0 &lt;= i &lt;= 19)$</p>
<p>     $K(i) = 6ED9EBA1$ for $20 &lt;= i &lt;= 39$</p>
<p>     $K(i) = 8F1BBCDC$ for $40 &lt;= i &lt;= 59$</p>
<p>     $K(i) = CA62C1D6$ for $60 &lt;= i &lt;= 79$</p>
<p>Reassign the following values:</p>
<p>$$ E = D$$</p>
<p>$$D = C$$</p>
<p>$$ C = S^30 (B)$$</p>
<p>$$B = A$$</p>
<p>$$ A = TEMP$$</p>
<p>Store the result of the chunk&rsquo;s hash to the overall hash value of all chunks as shown below, and proceed to execute the next chunk:</p>
<p>$$H_0 = H_0 + A$$</p>
<p>$$H_1 = H_1 + B$$</p>
<p>$$H_2 = H_2 + C$$</p>
<p>$$H_3 = H_3 + D$$</p>
<p>$$H_4 = H_4 + E$$</p>
<p>As a final step, when all chunks have been processed, the message digest is represented as the 160-bit string comprised of the OR logical operator and the 5 hashed values:</p>
<p>$$H = S^128 (H_0) \vee S^96 (H_2) \vee S^32(H_3) \vee H_4$$</p>
<hr>
<h1 id="sha-1-sucks">Sha-1 sucks<a hidden class="anchor" aria-hidden="true" href="#sha-1-sucks">#</a></h1>
<p>SHA-1 was broken quite a few years ago. By broken, I mean that it&rsquo;s possible to artificially create collisions. That is, given a document with an SHA-1 hash of &ldquo;cb4cc28df0fdbe0ecf9d9662e294b118092a5735&rdquo; it is possible to produce a different document that has the **same **hash.</p>
<p>This article used SHA-1 because it&rsquo;s relatively easy to explain when compared to non-broken hash functions such as SHA-5. If you want to learn more about why you shouldn&rsquo;t use SHA-1, read this <a href="https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html">article</a>.</p>
<p>As a side note, do not try to implement SHA-1 yourself. Remember <a href="https://www.schneier.com/blog/archives/2011/04/schneiers_law.html">Scheiner&rsquo;s rule</a>:</p>
<blockquote>
<p>&ldquo;Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can&rsquo;t break.&rdquo;</p>
</blockquote>
<p>While your implementation SHA-1 may appear to work to you, it may have some underlying issue that you didn&rsquo;t spot. It&rsquo;s always best to use implementations created and monitored by the community (open source).</p>
<hr>
<h2 id="breaking-hashes">Breaking hashes<a hidden class="anchor" aria-hidden="true" href="#breaking-hashes">#</a></h2>
<p>MD5 was a pretty popular hashing algorithm which produced 128-bit outputs. It is suspectible to a birthday attack.</p>
<p><a href="https://www.wikiwand.com/en/Birthday_attack">Birthday attacks </a>are formulated on the <a href="https://www.wikiwand.com/en/Birthday_problem">birthday problem</a>. If there are 23 people in a room, there is a 50% chance two of them will share the same birthday. If there are 70 people in a room, this is a 99.9% chance 2 people share the same birthday.</p>
<p>This comes from what is called the <em><a href="https://www.wikiwand.com/en/Pigeonhole_principle">pigeonhole principle</a></em>. If you have 9 pigeonholes (boxes to put pigeons in) and 10 pigeons, 2 pigeons will have to share the same hole.
<img src="/content/images/2019/02/image-15.png" alt="">
In fact, MD5 is so weak to collision resistance that a simple, household  2.4GHz Pentium Processor can compute artificial hash collisions within  seconds. Moreover, its extensive usage in the earlier days of the  current web has created tons of leaked MD5 pre-images online that can be  found with a simple Google search of their hash.</p>
<hr>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>The 3 rules to hashing algorithms are:</p>
<ol>
<li>A hashing algorithm needs to be reasonably fast to compute and reasonably fast to verify.</li>
<li>If you change one single bit anywhere in the message, the outputted string must look completely different.</li>
<li>You must avoid collisions.</li>
</ol>
<p>As we saw with SHA-1, it uses a compressor function to take a message and turn that message into a much smaller, hashed version. SHA-1 isn&rsquo;t used in the real world anymore, and it&rsquo;s not secure in the sense that collisions can be created. Although it&rsquo;s a nice historical example of how hashing algorithms work.</p>
<p>For more on SHA-1, check out the official document describing it <a href="https://www.ipa.go.jp/security/rfc/RFC3174EN.html">here</a>. If you&rsquo;re interested in what hash functions are used now (especially in cryptocurrencies, as well as the attacks on them and the differences this <a href="https://medium.com/zkcapital/the-state-of-hashing-algorithms-the-why-the-how-and-the-future-b21d5c0440de">article </a>is very good.</p>
<p>Hey 👋 Want to subscribe to my blog and stay up to date with posts similar to this one? Subscribe to my email list below. I won&rsquo;t spam you. I will only send you posts similar to this one 😊✨</p>
<pre><code>#myemail {
background-color: #f0f0f0;
color: black;
padding: 15px;
border-radius: 25px;
        width: 80%;
    margin: 0 auto;
}
#little {
color: grey;
    font-size: 10px;
    }
#email {
    width: 100%;
    padding: 10px;
    
    }
#submit {
    width: 100%;
    background: rgb(36,255,204);
    }
    #gdpr { width: 15px; height: 15px; }
</code></pre>
<h2 id="at-least-this-isnt-a-full-screen-pop-up-">At least this isn&rsquo;t a full screen pop up! 😅<a hidden class="anchor" aria-hidden="true" href="#at-least-this-isnt-a-full-screen-pop-up-">#</a></h2>
<pre><code>    Sign up now and get:
</code></pre>
<ul>
<li>A free 202 page book on algorithmic design paradigms</li>
<li>A free 107 page book on employability skills</li>
<li>And much more to help you become an awesome developer!</li>
</ul>
<p>Email</p>
<p>GDPR: I consent to receive promotional emails about your products and services.
HP</p>
<p>One click unsubscribe anytime.</p>
<p>If you&rsquo;re feeling extra generous, I have a <a href="https://www.paypal.me/BrandonSkerritt">PayPal </a> and even a <a href="https://www.patreon.com/user?u=15993188">Patreon</a>. I&rsquo;m  a university student who writes these blogs in their spare time. This blog is my full time job, so any and all donations are appreciated!</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://polymath.cloud/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://polymath.cloud/tags/infosec/">Infosec</a></li>
      <li><a href="https://polymath.cloud/tags/university/">University</a></li>
    </ul>






<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on twitter"
        href="https://twitter.com/intent/tweet/?text=Hash%20functions%20explained%20for%20non%20cryptographers&amp;url=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f&amp;hashtags=University%2cComputerScience%2cInfosec">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f&amp;title=Hash%20functions%20explained%20for%20non%20cryptographers&amp;summary=Hash%20functions%20explained%20for%20non%20cryptographers&amp;source=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f&title=Hash%20functions%20explained%20for%20non%20cryptographers">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on whatsapp"
        href="https://api.whatsapp.com/send?text=Hash%20functions%20explained%20for%20non%20cryptographers%20-%20https%3a%2f%2fpolymath.cloud%2fhash-functions%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Hash functions explained for non cryptographers on telegram"
        href="https://telegram.me/share/url?text=Hash%20functions%20explained%20for%20non%20cryptographers&amp;url=https%3a%2f%2fpolymath.cloud%2fhash-functions%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://polymath.cloud">Polymath.cloud</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://polymath.cloud/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
