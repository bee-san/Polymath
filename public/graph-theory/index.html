<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Graph Theory | Polymath.cloud</title>

<meta name="keywords" content="University, Computer Science" />
<meta name="description" content="If you want to learn a lot about Graph Theory, check out this article
The seven bridges of Koenigsberg is the foundation and birth of graph theory. There was a puzzle that stated:
 Can you cross all seven bridges exactly once?
 There are 2 rules for this problem:
 Do not cross any bridge twice All bridges must be crossed  In the 18th Century a mathematician called Euler realised this problem was impossible.">
<meta name="author" content="Bee">
<link rel="canonical" href="https://polymath.cloud/graph-theory/" />
<link href="https://polymath.cloud/assets/css/stylesheet.min.94a69f3d0b70cac76c6d6f7dfecc9f91f2319ec73d54be960b0d3624fa5a25e2.css" integrity="sha256-lKafPQtwysdsbW99/syfkfIxnsc9VL6WCw02JPpaJeI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://polymath.cloud/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://polymath.cloud/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://polymath.cloud/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://polymath.cloud/apple-touch-icon.png">
<link rel="mask-icon" href="https://polymath.cloud/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.68.3" />




<style>
    td, th {
    border: thin solid #999 !important;
    padding: 12px 15px;
}

thead tr {
    background-color: #009879;
    color: #ffffff;
    text-align: left;
}

table {
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 0.9em;
    font-family: sans-serif;
    min-width: 400px;
    overflow: auto;
    display: table;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
}

tbody tr {
    border-bottom: thin solid #dddddd;
}


tbody tr:last-of-type {
    border-bottom: 2px solid #009879;
}

tbody td.active-item {
    font-weight: bold;
    color: #009879;
}

tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
    }


body.dark tbody tr:nth-of-type(even) {
    background-color: #383838;
}


img {
    display: block;
    margin: auto;
    text-align: center;
}

</style>
<meta property="og:title" content="Graph Theory" />
<meta property="og:description" content="If you want to learn a lot about Graph Theory, check out this article
The seven bridges of Koenigsberg is the foundation and birth of graph theory. There was a puzzle that stated:
 Can you cross all seven bridges exactly once?
 There are 2 rules for this problem:
 Do not cross any bridge twice All bridges must be crossed  In the 18th Century a mathematician called Euler realised this problem was impossible." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://polymath.cloud/graph-theory/" />
<meta property="article:published_time" content="2019-10-10T16:18:20+00:00" />
<meta property="article:modified_time" content="2019-10-10T16:18:20+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Graph Theory"/>
<meta name="twitter:description" content="If you want to learn a lot about Graph Theory, check out this article
The seven bridges of Koenigsberg is the foundation and birth of graph theory. There was a puzzle that stated:
 Can you cross all seven bridges exactly once?
 There are 2 rules for this problem:
 Do not cross any bridge twice All bridges must be crossed  In the 18th Century a mathematician called Euler realised this problem was impossible."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Graph Theory",
  "name": "Graph Theory",
  "description": "If you want to learn a lot about Graph Theory, check out this article\nThe seven bridges of Koenigsberg is the foundation and birth of graph theory. There was a puzzle that stated: …",
  "keywords": [
    "University", "Computer Science"
  ],
  "articleBody": "If you want to learn a lot about Graph Theory, check out this article\nThe seven bridges of Koenigsberg is the foundation and birth of graph theory. There was a puzzle that stated:\n Can you cross all seven bridges exactly once?\n There are 2 rules for this problem:\n Do not cross any bridge twice All bridges must be crossed  In the 18th Century a mathematician called Euler realised this problem was impossible. Every bit of land you enter has to have 2 bridges, or an even number of bridges. One you can leave on, one you can enter on.\nYou’ll notice a part of the land does not have an even number of bridges, it actually has 3 bridges.\nLet’s move straight into graph theory.\nAn undirected graph G = (V, E) consists of a set of vertices V and a set of edges. It is an undirected graph because the edges do not have any direction. Each edge is an unordered pair of vertices. So {a, b} is the same as {b, a}.\nA directed graph G = (V, E) is where each vertex has a direction. Think of it like Facebook and Twitter. On Facebook when you friend someone, the other person is automatically a friend of you. image from here\nGraphs are used to model computer networks, state spaces of finite games such as Chess.\nHere are some of the different types of graphs:\nSimple Graph\nThe Simple Graph has at most 1 edge between 2 vertices and it has no self-loop. It has no edges that come from a vertex and go back to that same vertex.\nThis is not a simple graph: And this is not a simple graph, because a vertex exists with no edges connecting to it: This is a simple graph: Multi Graph\nA multi graph allows more than one edge between two vertices: More on Undirected Graphs and Terminology In an undirected graph, G, suppose that e = {u, v} is an edge of G u and v are said to be adjacent and are called neighbours of each other\ne is said to be incident with u and v\nu and v are called endpoints of e\ne is said to connect u and v\nThe degree of a vertex is how many edges are connected to it.\nThe degree of the graph is the maximum edges connected to a particular vertex. In this graph the degree is 3, since vertex u has degree 3 and is the largest degree in the graph.\nMatrix Representation of Graphs An undirected graph can be represented by an adjacency matrix.\nA matrix is like a vector or a set, it’s a storage unit to store numbers in it.\nAn adjacency matrix, M, for a simple undirected graph with n vertices is called an n x n matrix.\nIn this matrix if vertex i and vertex j are adjacent (neighbours) then you can represent this on the matrix with the number 1.\nIf they are not, use the number 0. To represent this in a matrix, we can do the following: Notice how the diagonal is 0’s and if you take half of the upper triangle it matches the bottom half.\nAn incident matrix is an m x n matrix where m is the number of edges in the graph.\nFor this graph again: We can use this incidence matrix to represent it: More on Directed Graphs An in-degree of a vertex, v, is the number of edges leading to v.\nAn out-degree of a vertex, v, is the number of edges leading away from v.\nThe in-degree is the same as the out-degree. It’s also the same as the number of edges.\n in degree sum = out degree sum\n Because this is an **undirected **graph, the in degree and out degree have to be the same for each vertex.\nIf the total sum of all in degrees does not match the total sum of all out degrees then it is not a tree.\nIf you have 2 out-degrees and 1 in-degree it is not a tree since there is an edge either travelling nowhere or travelling to the same node twice.\nA directed graph can be represented by an adjacency matrix or an incidence matrix.\nAdjacency Matrix An adjacency matrix, M, for a directed graph with n vertices is called an n x n matrix.\n M(i, j) is equal to 1 if (i, j) has an edge from i to j M(i, j) is otherwise 0.  An adjacency list is where each vertex, u, has a list of vertices pointed to by an edge leading away from u.\nThis is really nothing different from what we saw earlier.\nIncidence Matrix An incidence matrix for a directed graph with n vertices and m edges is an m x n matrix.\nThese are the basic rules:\n M(i, j) = 1 if edge i is leading away from vertex j (leaving) M(i, j) = -1 if edge i is leading to vertex j (into) M(i, j) = 0 otherwise  Incidence list is a list where each vertex, u, has a list of vertices pointed to by an edge leading away from u.\nCircuits A circuit, a path, a cycle are all sequences of vertices and edges.\nThey all have rules and properties which make them special, these are:\n Cycle: Vertices cannot repeat. Edges cannot repeat. Walk: Vertices may repeat. Edges may repeat. Circuit: Vertices may repeat. Edges cannot repeat.  Normally a circuit is defined as a path from vertex a, back to vertex a.\nA simple circuit visits an edge at most once (so never goes back to the same vertex).\nAn Euler circuit is a circuit visiting every edge exactly once (so can go back to the same vertex).\nThis is the exact same circuit Euler wanted to create on the Kronenbeig problem earlier. To cross every bridge (edge) exactly once, but allowing you to go to the vertexes (islands) as many times as you want.\nThe graph contains an Euler Circuit if and only if the degree of every vertex in the graph is even.\nAn Hamiltonian circuit (not named after Alexandria Hamilton) is a circuit containing every vertex of a graph, G, exactly once.\nIt does not matter in a Hamiltonian circuit whether or not you visit all of the edges.\nDetermining whether a graph contains a Hamiltonian circuit is an NP-hard problem. For information on NP-hardness click here.\nSearching on Trees / Graphs Okay, so we’ve met trees and graphs. But how do we search them? We can use some of these nifty search algorithms!\nBreadth First Search Breadth First Search (BFS) is a search algorithm developed by Konrad Zeus for his rejected PhD thesis in 1945. Breadth First Search searches all neighbours before it searches child nodes. In the below picture, once the start state (1) has been searched the states 2, 3, and 4 will then be searched. The Breadth First Search Algorithm has a queue which is vital to how it works. Breadth first will first check whether the current node it is searching is the goal state or not. If it is not the goal state, it places all child nodes of the current node being searched into a queue. As an example assume the queue will look like [5, 6, 3, 4].\nBecause of the first in first out nature, the first ones added to the queue are the first ones out of the queue, so it would search in the order 4, 3, 6, 5.\nBreadth first search searches in “levels”. It starts at level 1, [1], then goes down to level 2, [1:2, 1:3, 1:4]. When we look at a neighbour we need to see if it’s neighbours have been visited yet. In order to do this we need to “mark” the vertex to signify we haven’t looked at it yet.\nAdvantages Breadth-first search is complete, as in it will always find a path and the shortest path to the goal, assuming the goal is at a finite depth.\nSpace and Time Complexity — A Quick Detour Time complexity is how long it takes the algorithm to run given an input, usually denoted in Big O notation. Space complexity is how much the algorithm takes up in memory. Although this depends on the hardware factors, just like with Big O notation we can use a notation to represent how much space it’ll take up.\nConsider a theoretical tree where node state has b successors. The root of the search tree generates b nodes and the second level of the search tree generates b² nodes. Each level generates b more nodes, yielding b^n (b to the power of n) nodes where n is the level the search tree is on. So the time complexity is $$b^n$$.\nThe space complexity of this is b^d.\nYou may notice this looks different from Big O notation, well, for some reason a lot of AI researchers use this notation. In big O the space and time complexity is:\nO(|v|)\nWhere |v| is the number of nodes.\nI believe this notation is used because it is the notation used in the book “Artificial Intelligence: A Modern Approach” by Russel and Norvig and because this book is the book on Artificial Intelligence everyone uses their notation.\nb is the branching factor of the tree. d is the shallowest goal node (the lowest level at which a node is a goal for a given search problem) m is the maximum length of any path in the state space.\nDisadvantages Breadth First Search is very, very slow and requires a lot of memory, however, on a smaller graph / tree it is efficient.\nDepth First Search Depth First Search expands the deepest node in the current frontier first. Depth first search goes immediately to the deepest possible point of the search tree until there are no sucessors. In this example, Depth First Search will go straight to 9, then 10 and then to 6.\nWhereas Breadth First search uses a first in first out (FIFO) queue Depth First uses a a Last in Last out queue (LIFO). A LIFO queue means that the most recently generated node is chosen for expansion. The most recently generated node must be the deepest possible unexpanded node because it is deeper than its parent node.\nIf Depth First Search is used on a graph which avoids repeated states and redundant paths then it will find its goal in a finite number of states. If however it is used on a search tree then it will expand forever, in other words depth first search is not complete within search trees.\nDepth first search will not find the optimal path.\nThe time complexity of DFS is 1+ b² + b³ + … +b^m\nThe advantage of DFS over BFS is the space complexity. Once a path has been fully explored it can be removed from memory, so DFS only needs to store the root node, all the children of the root node and where it currently is. DFS requires space complexity of bm where b is the branching factor and m is the longest path in the graph. ",
  "wordCount" : "1868",
  "inLanguage": "en",
  "datePublished": "2019-10-10T16:18:20Z",
  "dateModified": "2019-10-10T16:18:20Z",
  "author":{
    "@type": "Person",
    "name": "Bee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://polymath.cloud/graph-theory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Polymath.cloud",
    "logo": {
      "@type": "ImageObject",
      "url": "https://polymath.cloud/favicon.ico"
    }
  }
}
</script>



</head>

<body class="">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://polymath.cloud" accesskey="h">Polymath.cloud</a>
            <span class="logo-switches">
                <span class="theme-toggle">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://polymath.cloud/archives" title="Archive">
                    <span>
                        Archive
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/search/" title="Search">
                    <span>
                        Search
                    </span>
                </a>
            </li>
            <li>
                <a href="https://polymath.cloud/tags/" title="Tags">
                    <span>
                        Tags
                    </span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Graph Theory
    </h1>
    <div class="post-meta">

October 10, 2019&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Bee

    </div>
  </header> 

  <div class="post-content">
<p>If you want to learn <strong>a lot</strong> about Graph Theory, check out this <a href="https://medium.freecodecamp.org/i-dont-understand-graph-theory-1c96572a1401">article</a></p>
<p>The seven bridges of Koenigsberg is the foundation and birth of graph theory.
<img src="https://cdn-images-1.medium.com/max/800/0*8qV9quKHTwt3AyIv." alt="">
There was a puzzle that stated:</p>
<blockquote>
<p><em>Can you cross all seven bridges exactly once?</em></p>
</blockquote>
<p><img src="https://cdn-images-1.medium.com/max/800/0*fTdG-c6rex0j3Jic." alt="">
There are 2 rules for this problem:</p>
<ol>
<li>Do not cross any bridge twice</li>
<li>All bridges must be crossed</li>
</ol>
<p>In the 18th Century a mathematician called Euler realised this problem was impossible. Every bit of land you enter has to have 2 bridges, or an even number of bridges. One you can leave on, one you can enter on.</p>
<p>You’ll notice a part of the land does not have an even number of bridges, it actually has 3 bridges.</p>
<p>Let’s move straight into graph theory.</p>
<p>An <strong>undirected</strong> graph G = (V, E) consists of a set of vertices V and a set of edges. It is an undirected graph because the edges do not have any direction.
<img src="https://cdn-images-1.medium.com/max/800/0*M2pGrHm4svMhHtF7.png" alt="">
Each edge is an unordered pair of vertices. So {a, b} is the same as {b, a}.</p>
<p>A <strong>directed</strong> graph G = (V, E) is where each vertex has a direction.
<img src="https://cdn-images-1.medium.com/max/800/0*EBAJnOkMtW0nAHwQ.png" alt="">
Think of it like Facebook and Twitter. On Facebook when you friend someone, the other person is automatically a friend of you.
<img src="https://cdn-images-1.medium.com/max/800/0*K1gP0fXBUa6na_O6." alt="">
image from <a href="https://www.safaribooksonline.com/library/view/mining-the-social/9781449368180/ch02.html">here</a></p>
<p>Graphs are used to model computer networks, state spaces of finite games such as Chess.</p>
<p>Here are some of the different types of graphs:</p>
<p><strong>Simple Graph</strong></p>
<p>The Simple Graph has at most 1 edge between 2 vertices and it has no self-loop. It has no edges that come from a vertex and go back to that same vertex.</p>
<p>This is <strong>not</strong> a simple graph:
<img src="https://cdn-images-1.medium.com/max/800/0*DxErx2Di72tCKId-.png" alt="">
And this is not a simple graph, because a vertex exists with no edges connecting to it:
<img src="https://cdn-images-1.medium.com/max/800/0*6yhIVTJjNp_PZuq9.png" alt="">
This is a simple graph:
<img src="https://cdn-images-1.medium.com/max/800/0*NwvbMPI5TanGn_Ia.png" alt="">
<strong>Multi Graph</strong></p>
<p>A multi graph allows more than one edge between two vertices:
<img src="https://cdn-images-1.medium.com/max/800/0*8NzQ8VsuPIlMCzbh.png" alt=""></p>
<h3 id="more-on-undirected-graphs-and-terminology">More on Undirected Graphs and Terminology<a hidden class="anchor" aria-hidden="true" href="#more-on-undirected-graphs-and-terminology">#</a></h3>
<p>In an undirected graph, G, suppose that e = {u, v} is an edge of G
<img src="https://cdn-images-1.medium.com/max/800/0*xR-VKQywFaamo17g.jpg" alt="">
u and v are said to be <strong>adjacent</strong> and are called <strong>neighbours</strong> of each other</p>
<p>e is said to be <strong>incident</strong> with u and v</p>
<p>u and v are called <strong>endpoints</strong> of e</p>
<p>e is said to <strong>connect</strong> u and v</p>
<p>The degree of a vertex is how many edges are connected to it.</p>
<p>The degree of the graph is the maximum edges connected to a particular vertex. In this graph the degree is 3, since vertex u has degree 3 and is the largest degree in the graph.</p>
<h3 id="matrix-representation-of-graphs">Matrix Representation of Graphs<a hidden class="anchor" aria-hidden="true" href="#matrix-representation-of-graphs">#</a></h3>
<p>An undirected graph can be represented by an adjacency matrix.</p>
<p>A matrix is like a vector or a set, it’s a storage unit to store numbers in it.</p>
<p>An <strong>adjacency matrix</strong>, M, for a simple undirected graph with n vertices is called an <strong>n x n matrix</strong>.</p>
<p>In this matrix if vertex i and vertex j are adjacent (neighbours) then you can represent this on the matrix with the number 1.</p>
<p>If they are not, use the number 0.
<img src="https://cdn-images-1.medium.com/max/800/0*EWqjoLnwnVjLo0Ad.png" alt="">
To represent this in a matrix, we can do the following:
<img src="https://cdn-images-1.medium.com/max/800/0*9V3pZxz9afjVn7Us.png" alt="">
Notice how the diagonal is 0’s and if you take half of the upper triangle it matches the bottom half.</p>
<p>An <strong>incident matrix</strong> is an m x n matrix where m is the number of edges in the graph.</p>
<p>For this graph again:
<img src="https://cdn-images-1.medium.com/max/800/0*LixjPCetdV5wjpVi.png" alt="">
We can use this incidence matrix to represent it:
<img src="https://cdn-images-1.medium.com/max/800/0*W-wY5IusanG4Hltv." alt=""></p>
<h3 id="more-on-directed-graphs">More on Directed Graphs<a hidden class="anchor" aria-hidden="true" href="#more-on-directed-graphs">#</a></h3>
<p>An <strong>in-degree</strong> of a vertex, v, is the number of edges leading to v.</p>
<p>An <strong>out-degree</strong> of a vertex, v, is the number of edges leading away from v.</p>
<p>The <strong>in-degree</strong> is the same as the <strong>out-degree</strong>. It’s also the same as the number of edges.</p>
<blockquote>
<p>in degree sum = out degree sum</p>
</blockquote>
<p>Because this is an **undirected **graph, the in degree and out degree have to be the same for each vertex.</p>
<p>If the total sum of all in degrees does not match the total sum of all out degrees then it is not a tree.</p>
<p>If you have 2 out-degrees and 1 in-degree it is not a tree since there is an edge either travelling nowhere or travelling to the same node twice.</p>
<p>A directed graph can be represented by an adjacency matrix or an incidence matrix.</p>
<h3 id="adjacency-matrix">Adjacency Matrix<a hidden class="anchor" aria-hidden="true" href="#adjacency-matrix">#</a></h3>
<p>An <strong>adjacency matrix</strong>, M, for a directed graph with n vertices is called an n x n matrix.</p>
<ul>
<li>M(i, j) is equal to 1 if (i, j) has an edge from i to j</li>
<li>M(i, j) is otherwise 0.</li>
</ul>
<p>An <strong>adjacency list</strong> is where each vertex, u, has a list of vertices pointed to by an edge leading away from u.</p>
<p>This is really nothing different from what we saw earlier.</p>
<h3 id="incidence-matrix">Incidence Matrix<a hidden class="anchor" aria-hidden="true" href="#incidence-matrix">#</a></h3>
<p>An <strong>incidence matrix</strong> for a directed graph with n vertices and m edges is an m x n matrix.</p>
<p>These are the basic rules:</p>
<ul>
<li>M(i, j) = 1 if edge i is leading away from vertex j (leaving)</li>
<li>M(i, j) = -1 if edge i is leading to vertex j (into)</li>
<li>M(i, j) = 0 otherwise</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/800/0*RJQWk84SCEpF_sON.png" alt=""><img src="https://cdn-images-1.medium.com/max/800/0*NP9ha6hdCWs4PUqm." alt="">
<strong>Incidence list</strong> is a list where each vertex, u, has a list of vertices pointed to by an edge leading away from u.</p>
<h3 id="circuits">Circuits<a hidden class="anchor" aria-hidden="true" href="#circuits">#</a></h3>
<p>A circuit, a path, a cycle are all sequences of vertices and edges.</p>
<p>They all have rules and properties which make them special, these are:</p>
<ul>
<li>Cycle: Vertices cannot repeat. Edges cannot repeat.</li>
<li>Walk: Vertices may repeat. Edges may repeat.</li>
<li>Circuit: Vertices may repeat. Edges cannot repeat.</li>
</ul>
<p>Normally a circuit is defined as a path from vertex a, back to vertex a.</p>
<p>A <strong>simple</strong> circuit visits an edge at most once (so never goes back to the same vertex).</p>
<p>An <strong>Euler circuit</strong> is a circuit visiting every edge exactly once (so can go back to the same vertex).</p>
<p>This is the exact same circuit Euler wanted to create on the Kronenbeig problem earlier. To cross every bridge (edge) exactly once, but allowing you to go to the vertexes (islands) as many times as you want.</p>
<p>The graph contains an Euler Circuit if and only if the degree of every vertex in the graph is even.</p>
<p>An <strong>Hamiltonian circuit</strong> (not named after Alexandria Hamilton) is a circuit containing <strong>every vertex</strong> of a graph, G, exactly once.</p>
<p>It does not matter in a Hamiltonian circuit whether or not you visit all of the edges.</p>
<p>Determining whether a graph contains a Hamiltonian circuit is an NP-hard problem. For information on NP-hardness click <a href="https://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard">here</a>.</p>
<h3 id="searching-on-trees--graphs">Searching on Trees / Graphs<a hidden class="anchor" aria-hidden="true" href="#searching-on-trees--graphs">#</a></h3>
<p>Okay, so we’ve met trees and graphs. But how do we search them? We can use some of these nifty search algorithms!</p>
<h3 id="breadth-first-search">Breadth First Search<a hidden class="anchor" aria-hidden="true" href="#breadth-first-search">#</a></h3>
<p>Breadth First Search (BFS) is a search algorithm developed by Konrad Zeus for his rejected PhD thesis in 1945. Breadth First Search searches all neighbours before it searches child nodes. In the below picture, once the start state (1) has been searched the states 2, 3, and 4 will then be searched.
<img src="https://cdn-images-1.medium.com/max/800/0*N2zZ4MzcgxUvRqiy." alt="">
The Breadth First Search Algorithm has a queue which is vital to how it works. Breadth first will first check whether the current node it is searching is the goal state or not. If it is not the goal state, it places all child nodes of the current node being searched into a queue. As an example assume the queue will look like [5, 6, 3, 4].</p>
<p>Because of the first in first out nature, the first ones added to the queue are the first ones out of the queue, so it would search in the order 4, 3, 6, 5.</p>
<p>Breadth first search searches in “levels”. It starts at level 1, [1], then goes down to level 2, [1:2, 1:3, 1:4].
<img src="https://cdn-images-1.medium.com/max/800/0*yiTa2mEheuL0hSgm." alt="">
When we look at a neighbour we need to see if it’s neighbours have been visited yet. In order to do this we need to “mark” the vertex to signify we haven’t looked at it yet.</p>
<h3 id="advantages">Advantages<a hidden class="anchor" aria-hidden="true" href="#advantages">#</a></h3>
<p>Breadth-first search is complete, as in it will always find a path and the shortest path to the goal, assuming the goal is at a finite depth.</p>
<h3 id="space-and-time-complexitya-quick-detour">Space and Time Complexity — A Quick Detour<a hidden class="anchor" aria-hidden="true" href="#space-and-time-complexitya-quick-detour">#</a></h3>
<p>Time complexity is how long it takes the algorithm to run given an input, usually denoted in <a href="https://skerritt.blog/big-o/">Big O notation</a>. Space complexity is how much the algorithm takes up in memory. Although this depends on the hardware factors, just like with <a href="https://skerritt.blog/big-o/">Big O notation</a> we can use a notation to represent how much space it’ll take up.</p>
<p>Consider a theoretical tree where node state has b successors. The root of the search tree generates b nodes and the second level of the search tree generates b² nodes. Each level generates b more nodes, yielding b^n (b to the power of n) nodes where n is the level the search tree is on. So the <strong>time complexity</strong> is $$b^n$$.</p>
<p>The <strong>space complexity</strong> of this is b^d.</p>
<p>You may notice this looks different from Big O notation, well, for some reason a lot of AI researchers use this notation. In big O the space and time complexity is:</p>
<p>O(|v|)</p>
<p>Where |v| is the number of nodes.</p>
<p>I believe this notation is used because it is the notation used in the book “Artificial Intelligence: A Modern Approach” by Russel and Norvig and because this book is <strong>the</strong> book on Artificial Intelligence everyone uses their notation.</p>
<p><strong>b</strong> is the branching factor of the tree. <strong>d</strong> is the shallowest goal node (the lowest level at which a node is a goal for a given search problem) <strong>m</strong> is the maximum length of any path in the state space.</p>
<h3 id="disadvantages">Disadvantages<a hidden class="anchor" aria-hidden="true" href="#disadvantages">#</a></h3>
<p>Breadth First Search is very, very slow and requires a lot of memory, however, on a smaller graph / tree it is efficient.</p>
<h3 id="depth-first-search">Depth First Search<a hidden class="anchor" aria-hidden="true" href="#depth-first-search">#</a></h3>
<p>Depth First Search expands the deepest node in the current frontier first. Depth first search goes immediately to the deepest possible point of the search tree until there are no sucessors.
<img src="https://cdn-images-1.medium.com/max/800/0*fbMyTjqrKMTovHmg." alt="">
In this example, Depth First Search will go straight to 9, then 10 and then to 6.</p>
<p>Whereas Breadth First search uses a first in first out (FIFO) queue Depth First uses a a Last in Last out queue (LIFO). A LIFO queue means that the most recently generated node is chosen for expansion. The most recently generated node must be the deepest possible unexpanded node because it is deeper than its parent node.</p>
<p>If Depth First Search is used on a graph which avoids repeated states and redundant paths then it will find its goal in a finite number of states. If however it is used on a search tree then it will expand forever, in other words depth first search is not complete within search trees.</p>
<p>Depth first search will not find the optimal path.</p>
<p>The time complexity of DFS is 1+ b² + b³ + … +b^m</p>
<p>The advantage of DFS over BFS is the space complexity. Once a path has been fully explored it can be removed from memory, so DFS only needs to store the root node, all the children of the root node and where it currently is. DFS requires space complexity of bm where b is the branching factor and m is the longest path in the graph.
<img src="https://cdn-images-1.medium.com/max/800/0*YejaalLx0mIEeSJT." alt=""></p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://polymath.cloud/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://polymath.cloud/tags/university/">University</a></li>
    </ul>






<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on twitter"
        href="https://twitter.com/intent/tweet/?text=Graph%20Theory&amp;url=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f&amp;hashtags=University%2cComputerScience">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f&amp;title=Graph%20Theory&amp;summary=Graph%20Theory&amp;source=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f&title=Graph%20Theory">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on whatsapp"
        href="https://api.whatsapp.com/send?text=Graph%20Theory%20-%20https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Graph Theory on telegram"
        href="https://telegram.me/share/url?text=Graph%20Theory&amp;url=https%3a%2f%2fpolymath.cloud%2fgraph-theory%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://polymath.cloud">Polymath.cloud</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<button class="top-link" id="top-link" type="button" aria-label="go to top" title="Go to Top" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
        <path d="M12 6H0l6-6z" /></svg>
</button>



<script defer src="https://polymath.cloud/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    mybutton.onclick = function () {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
        window.location.hash = ''
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
